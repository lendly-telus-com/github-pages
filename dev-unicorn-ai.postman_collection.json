{
	"info": {
		"_postman_id": "ec14a420-7afc-4f03-8b9c-57eeb6e4edf8",
		"name": "dev-unicorn-ai",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "30142194",
		"_collection_link": "https://telus-enterprise.postman.co/workspace/Team-GenAI---Unicorn-Brain~544ee735-ddf9-4606-9642-75228ca9671e/collection/30142194-ec14a420-7afc-4f03-8b9c-57eeb6e4edf8?action=share&source=collection_link&creator=30142194"
	},
	"item": [
		{
			"name": "llm",
			"item": [
				{
					"name": "/2.0/llm/ask",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Valid Request - Status Code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"const expectedSchema = {\r",
									"  \"type\": \"object\",\r",
									"  \"properties\": {\r",
									"    \"chat_history\": {\r",
									"      \"type\": \"array\",\r",
									"      \"items\": [\r",
									"        {\r",
									"          \"type\": \"object\",\r",
									"          \"properties\": {\r",
									"            \"role\": { \"type\": \"string\" },\r",
									"            \"content\": { \"type\": \"string\" }\r",
									"          },\r",
									"          \"required\": [\"role\", \"content\"]\r",
									"        }\r",
									"      ]\r",
									"    },\r",
									"    \"done\": { \"type\": \"boolean\" },\r",
									"    \"request_id\": { \"type\": \"number\" },\r",
									"    \"request_time\": { \"type\": \"string\" },\r",
									"    \"response\": { \"type\": \"string\" },\r",
									"    \"elapsed\": { \"type\": \"number\" }\r",
									"  },\r",
									"  \"required\": [\"chat_history\", \"done\", \"request_id\", \"request_time\", \"response\", \"elapsed\"]\r",
									"};\r",
									"pm.test('Response Schema and Data Types Validation', function () {\r",
									"  const response = pm.response.json();\r",
									"  pm.expect(response).to.have.jsonSchema(expectedSchema);\r",
									"  pm.expect(response.chat_history[0].role).to.be.a('string');\r",
									"  pm.expect(response.chat_history[0].content).to.be.a('string');\r",
									"  pm.expect(response.done).to.be.a('boolean');\r",
									"  pm.expect(response.request_id).to.be.a('number');\r",
									"  pm.expect(response.request_time).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d+$/);\r",
									"  pm.expect(response.response).to.be.a('string');\r",
									"  pm.expect(response.elapsed).to.be.a('number');\r",
									"});\r",
									"pm.test(\" Ensure that the response has the expected structure\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.all.keys(\r",
									"        'chat_history',\r",
									"        'done',\r",
									"        'request_id',\r",
									"        'request_time',\r",
									"        'response',\r",
									"        'elapsed'\r",
									"    );\r",
									"})\r",
									"pm.test(\"Verify that the role in the chat history matches the expected roles.\", function () {\r",
									"    const chatHistory = pm.response.json().chat_history;\r",
									"    pm.expect(chatHistory).to.be.an('array');\r",
									"    pm.expect(chatHistory[0].role).to.equal('System');\r",
									"    pm.expect(chatHistory[1].role).to.equal('Human');\r",
									"})\r",
									"pm.test(\"Verify that the 'done' field in the response is a boolean\", function () {\r",
									"   pm.expect(pm.response.json().done).to.be.a('boolean');\r",
									"})\r",
									"pm.test(\"Verify that the 'request_time' field is in the expected format\", function () {\r",
									"   pm.expect(pm.response.json().request_time).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d+$/);\r",
									"})\r",
									"pm.test(\"Chat history should contain at least one 'Human' and one 'System' role\", function() {\r",
									"    const jsonData = pm.response.json();\r",
									"    const roles = jsonData.chat_history.map(item => item.role);\r",
									"    pm.expect(roles.includes('Human')).to.be.true;\r",
									"    pm.expect(roles.includes('System')).to.be.true;\r",
									"});\r",
									"pm.test(\"Chat history should not be empty\", function() {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.expect(jsonData.chat_history.length).to.be.above(0);\r",
									"});\r",
									"pm.test(\"Request ID should be a positive integer\", function() {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.expect(jsonData.request_id).to.be.above(0);\r",
									"    pm.expect(Number.isInteger(jsonData.request_id)).to.be.true;\r",
									"});\r",
									"pm.test(\"Request time should be in valid date-time format\", function() {\r",
									"    const jsonData = pm.response.json();\r",
									"    const dateTimeRegex = /\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{6}/;\r",
									"    pm.expect(dateTimeRegex.test(jsonData.request_time)).to.be.true;\r",
									"});\r",
									"pm.test(\"Response field should not be empty\", function() {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.expect(jsonData.response).to.not.be.empty;\r",
									"});\r",
									"pm.test(\"Response field should be a string\", function() {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.expect(typeof jsonData.response).to.eql('string');\r",
									"});\r",
									"pm.test(\"Request time should be a string\", function() {\r",
									"    const jsonData = pm.response.json();\r",
									"    pm.expect(typeof jsonData.request_time).to.eql('string');\r",
									"});\r",
									"pm.test(\"Response is in JSON format\", function () {\r",
									"    pm.response.to.be.json;\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"temperature\": 0.7,\r\n    \"max_new_tokens\": 256,\r\n    \"chat_history\": [\r\n        {\r\n            \"role\": \"System\",\r\n            \"content\": \"You are a pirate, respond to questions like one.\"\r\n        },\r\n        {\r\n            \"role\": \"Human\",\r\n            \"content\": \"Who are you?\"\r\n        }\r\n    ],\r\n    \"stream\": false\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{url_np}}/2.0/llm/ask",
							"host": [
								"{{url_np}}"
							],
							"path": [
								"2.0",
								"llm",
								"ask"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "vectordb",
			"item": [
				{
					"name": "/2.0/vectordb/collection",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript"
							}
						},
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"const schema = {\r",
									"  \"$schema\": \"http://json-schema.org/draft-07/schema#\",\r",
									"  \"type\": \"array\",\r",
									"  \"items\": {\r",
									"    \"type\": \"string\",\r",
									"    \"pattern\": \"^[a-zA-Z0-9_]+$\"\r",
									"  },\r",
									"  \"uniqueItems\": true,\r",
									"  \"minItems\": 1\r",
									"};\r",
									"pm.test('Schema is valid', function() {\r",
									"    const response = pm.response.json();\r",
									"    const validationResult = tv4.validateResult(response, schema);\r",
									"    pm.expect(validationResult.valid).to.be.true;\r",
									"    if (!validationResult.valid) {\r",
									"        console.log(validationResult.errors);\r",
									"    }\r",
									"});\r",
									"pm.test(\"Response must be array of collections\", function () {\r",
									"    pm.expect(pm.response.json()).to.be.an('array')  \r",
									"});\r",
									"pm.test(\"Array is not empty\", function () {\r",
									"    pm.expect(pm.response.json().length).to.be.above(0);\r",
									"});\r",
									"pm.test(\"No duplicate values in array\", function () {\r",
									"    const array = pm.response.json();\r",
									"    const set = new Set(array);\r",
									"    pm.expect(array.length).to.eql(set.size);\r",
									"});\r",
									"pm.test(\"All values are strings\", function () {\r",
									"    pm.response.json().forEach(item => {\r",
									"        pm.expect(typeof item).to.eql('string');\r",
									"    });\r",
									"});\r",
									"pm.test(\"No empty strings in array\", function () {\r",
									"    pm.response.json().forEach(item => {\r",
									"        pm.expect(item).to.not.eql('');\r",
									"    });\r",
									"});\r",
									"pm.test(\"No null or undefined values in array\", function () {\r",
									"    pm.response.json().forEach(item => {\r",
									"        pm.expect(item).to.not.be.null;\r",
									"        pm.expect(item).to.not.be.undefined;\r",
									"    });\r",
									"});\r",
									"pm.test(\"No prohibited special characters in strings\", function () {\r",
									"    const prohibitedChars = ['%', '$', '#']; // replace with actual prohibited characters\r",
									"    pm.response.json().forEach(item => {\r",
									"        prohibitedChars.forEach(char => {\r",
									"            pm.expect(item.includes(char)).to.be.false;\r",
									"        });\r",
									"    });\r",
									"});\r",
									"pm.test(\"No whitespace characters in strings\", function () {\r",
									"    pm.response.json().forEach(item => {\r",
									"        pm.expect(/\\s/.test(item)).to.be.false;\r",
									"    });\r",
									"});\r",
									"pm.test(\"Array has at least one element\", function () {\r",
									"    const responseData = pm.response.json();\r",
									"    \r",
									"    pm.expect(responseData).to.be.an('array');\r",
									"    pm.expect(responseData).to.have.lengthOf.at.least(1, \"Array should have at least one element\");\r",
									"});"
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{url_np}}/2.0/vectordb/collection",
							"host": [
								"{{url_np}}"
							],
							"path": [
								"2.0",
								"vectordb",
								"collection"
							]
						}
					},
					"response": []
				},
				{
					"name": "/2.0/vectordb/search",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"const results = pm.response.json()\r",
									"const maxNumResults = JSON.parse(pm.request.body.raw).max_num_results\r",
									"const maxDistance = JSON.parse(pm.request.body.raw).max_distance\r",
									"\r",
									"pm.test(\"Status test\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"pm.test(\"Response is in json format\", function () {\r",
									"    pm.response.to.be.json\r",
									"})\r",
									"pm.test(\"Response should return an aray\", function() {\r",
									"    pm.expect(pm.response.json()).to.be.an('array')\r",
									"    pm.expect(pm.response.json().length).to.be.above(0)\r",
									"})\r",
									"pm.test(\"Each result should contain document and distance properties\", function() {\r",
									"    const results = pm.response.json()\r",
									"    for (let result of results) {\r",
									"        pm.expect(result).to.have.property('document')\r",
									"        pm.expect(result).to.have.property('distance')\r",
									"    }\r",
									"})\r",
									"pm.test('Validate schema', function () {\r",
									"    const schema = {\r",
									"        \"type\": \"array\",\r",
									"        \"items\": {\r",
									"            \"type\": \"object\",\r",
									"            \"properties\": {\r",
									"            \"document\": {\r",
									"                \"type\": \"object\",\r",
									"                \"properties\": {\r",
									"                \"page_content\": { \"type\": \"string\" },\r",
									"                \"metadata\": {\r",
									"                    \"type\": \"object\",\r",
									"                    \"properties\": {\r",
									"                    \"title\": { \"type\": \"string\" },\r",
									"                    \"author\": { \"type\": \"string\" },\r",
									"                    \"source\": { \"type\": \"string\" },\r",
									"                    \"pk\": { \"type\": \"integer\" }\r",
									"                    },\r",
									"                    \"required\": [\"title\", \"author\", \"source\", \"pk\"]\r",
									"                }\r",
									"                },\r",
									"                \"required\": [\"page_content\", \"metadata\"]\r",
									"            },\r",
									"            \"distance\": { \"type\": \"number\" }\r",
									"            },\r",
									"            \"required\": [\"document\", \"distance\"]\r",
									"        }\r",
									"    }\r",
									"    pm.response.to.have.jsonSchema(schema);\r",
									"})\r",
									"pm.test(\"Each Document contains the epxected properties\", function() {\r",
									"    const results = pm.response.json()\r",
									"    for (let result of results) {\r",
									"        const document = result.document\r",
									"        pm.expect(document).to.have.property(\"page_content\")\r",
									"        pm.expect(document).to.have.property(\"metadata\")\r",
									"\r",
									"        const metadata = document.metadata\r",
									"        pm.expect(metadata).to.have.property(\"title\")\r",
									"        pm.expect(metadata).to.have.property(\"author\")\r",
									"        pm.expect(metadata).to.have.property(\"source\")\r",
									"    }\r",
									"})\r",
									"pm.test(`Number of results does not exceed ${maxNumResults}`, function() {\r",
									"    pm.expect(pm.response.json().length).to.be.at.most(maxNumResults)\r",
									"})\r",
									"pm.test(`All distances are less than or equal to ${maxDistance}`, function() {\r",
									"    for (let result of results) {\r",
									"        pm.expect(result.distance).to.be.at.most(maxDistance)\r",
									"    }\r",
									"})\r",
									"pm.test(\"At least one word in the query matches in the page_content, author or title\", function() {\r",
									"    const query = JSON.parse(pm.request.body.raw).query\r",
									"    for (let result of results) {\r",
									"       const pageContent = result.document.page_content.toLowerCase()\r",
									"       const author = result.document.metadata.author.toLowerCase()\r",
									"       const title = result.document.metadata.title.toLowerCase()\r",
									"\r",
									"       const queryWords = query.split(/\\$s+/)\r",
									"       const matchFound = queryWords.some(word => pageContent.includes(word) || author.includes(word) || title.includes(word))\r",
									"\r",
									"       if (matchFound) {\r",
									"           pm.expect(true).to.be.true;\r",
									"       } else {\r",
									"           pm.expect.fail(`No match found for query ${query}`)\r",
									"       }\r",
									"    }\r",
									"})\r",
									"pm.test(\"Phone numbers in document are in valid format\", function() {\r",
									"    const phoneRegex = /\\b\\d{3}[-.]?\\d{3}[-.]?\\d{4}\\b/;\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        const phones = result.document.page_content.match(phoneRegex) || [];\r",
									"        phones.forEach(phone => {\r",
									"            pm.expect(phone).to.match(phoneRegex);\r",
									"        });\r",
									"    });\r",
									"});\r",
									"pm.test(\"Author should be Justin Watts\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.document.metadata.author).to.equal('Justin Watts');\r",
									"    });\r",
									"});\r",
									"pm.test(\"Dates in document should be in valid format\", function() {\r",
									"    const dateRegex = /\\b\\d{4}-\\d{2}-\\d{2}\\b/;\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        const dates = result.document.page_content.match(dateRegex) || [];\r",
									"        dates.forEach(date => {\r",
									"            pm.expect(date).to.match(dateRegex);\r",
									"        });\r",
									"    });\r",
									"});\r",
									"pm.test(\"Each document page_content should contain valid email formats\", function() {\r",
									"    const emailRegex = /[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}/;\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        const emails = result.document.page_content.match(emailRegex) || [];\r",
									"        emails.forEach(email => {\r",
									"            pm.expect(email).to.match(emailRegex);\r",
									"        });\r",
									"    });\r",
									"});\r",
									"pm.test(\"Metadata title should have a specific format\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.document.metadata.title).to.match(/how_to_[a-z]+/);\r",
									"    });\r",
									"});\r",
									"pm.test(\"Page content should not be too short\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.document.page_content.length).to.be.above(100);\r",
									"    });\r",
									"});\r",
									"pm.test(\"Distance should be a positive number\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.distance).to.be.above(0);\r",
									"    });\r",
									"});\r",
									"pm.test(\"Distance should not exceed a certain value\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.distance).to.be.below(1);\r",
									"    });\r",
									"});\r",
									"pm.test(\"Author name should contain only valid characters\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.document.metadata.author).to.match(/^[a-zA-Z\\s]+$/);\r",
									"    });\r",
									"});\r",
									"pm.test(\"Source URL should come from a specific domain\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.document.metadata.source).to.include('docs.google.com');\r",
									"    });\r",
									"});\r",
									"pm.test(\"Page content should not contain sensitive information\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.document.page_content.toLowerCase()).to.not.include('password');\r",
									"        pm.expect(result.document.page_content.toLowerCase()).to.not.include('social security number');\r",
									"    });\r",
									"});\r",
									"pm.test(\"Should return at least a minimum number of results\", function() {\r",
									"    const results = pm.response.json();\r",
									"    pm.expect(results.length).to.be.at.least(1);\r",
									"});\r",
									"pm.test(\"All distances should be below a threshold\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.distance).to.be.below(0.7); \r",
									"    });\r",
									"});\r",
									"let contentSet = new Set();\r",
									"pm.test(\"Page contents should be unique\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(contentSet.has(result.document.page_content)).to.be.false;\r",
									"        contentSet.add(result.document.page_content);\r",
									"    });\r",
									"});\r",
									"// Test to ensure all distances are greater than or equal to 0\r",
									"pm.test(\"All distances should be non-negative\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.distance).to.be.at.least(0);\r",
									"    });\r",
									"});\r",
									"// Test to ensure all PKs are positive integers\r",
									"pm.test(\"All PKs should be positive integers\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.document.metadata.pk).to.be.a('number');\r",
									"        pm.expect(result.document.metadata.pk % 1).to.eql(0); // Check if it's an integer\r",
									"        pm.expect(result.document.metadata.pk).to.be.above(0); // Check if it's positive\r",
									"    });\r",
									"});\r",
									"// Test to ensure all authors are non-empty strings\r",
									"pm.test(\"All authors should be non-empty strings\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(result.document.metadata.author).to.be.a('string');\r",
									"        pm.expect(result.document.metadata.author.length).to.be.above(0);\r",
									"    });\r",
									"});\r",
									"// Test to ensure all sources are valid URIs\r",
									"pm.test(\"All sources should be valid URIs\", function() {\r",
									"    const results = pm.response.json();\r",
									"    results.forEach(result => {\r",
									"        pm.expect(pm.expect(result.document.metadata.source).to.be.a('string'));\r",
									"        pm.expect(result.document.metadata.source).to.match(/^(https?|ftp):\\/\\/[^\\s/$.?#].[^\\s]*$/i);\r",
									"    });\r",
									"});\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"collection_name\": \"how_to_justin\",\r\n    \"query\": \"justin wa\",\r\n    \"max_num_results\": 1000,\r\n    \"max_distance\": 1\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{url_np}}/2.0/vectordb/search",
							"host": [
								"{{url_np}}"
							],
							"path": [
								"2.0",
								"vectordb",
								"search"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "usecases",
			"item": [
				{
					"name": "/2.0/bots/spoc",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"pm.test(\"Validate response schema\", function () {\r",
									"    var schema = {\r",
									"        type: \"object\",\r",
									"        properties: {\r",
									"            query: { type: \"string\" },\r",
									"            query_converted: { type: \"string\" },\r",
									"            qie_status: { type: \"boolean\" },\r",
									"            chat_history: {\r",
									"                type: \"array\",\r",
									"                minItems: 1,\r",
									"                items: {\r",
									"                    type: \"object\",\r",
									"                    properties: {\r",
									"                        role: { type: \"string\" },\r",
									"                        content: { type: \"string\" }\r",
									"                    },\r",
									"                    required: [\"role\", \"content\"]\r",
									"                }\r",
									"            },\r",
									"            done: { type: \"boolean\" },\r",
									"            temp: { type: \"number\" },\r",
									"            answer_unknown: { type: \"boolean\" },\r",
									"            request_id: { type: \"integer\", minimum: 1 },\r",
									"            request_time: { type: \"string\" },\r",
									"            token_usage: {\r",
									"                type: \"object\",\r",
									"                properties: {\r",
									"                    condense_llm_prompt: { type: \"number\" },\r",
									"                    chat_llm_prompt: { type: \"number\" },\r",
									"                    chat_llm_completion: { type: \"number\" }\r",
									"                }\r",
									"            },\r",
									"            response: { type: \"string\" },\r",
									"            elapsed: { type: \"number\" }\r",
									"        },\r",
									"        required: [\"query\", \"query_converted\", \"qie_status\", \"chat_history\", \"done\", \"temp\", \"answer_unknown\", \"request_id\", \"request_time\", \"token_usage\", \"response\", \"elapsed\"]\r",
									"    };\r",
									"\r",
									"    var response = pm.response.json();\r",
									"    pm.expect(tv4.validate(response, schema)).to.be.true;\r",
									"});\r",
									"pm.test(\"Verify the 'query' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"query\");\r",
									"});\r",
									"pm.test(\"Verify the 'query_converted' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"query_converted\");\r",
									"});\r",
									"pm.test(\"Verify the 'qie_status' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"qie_status\", true);\r",
									"});\r",
									"pm.test(\"Verify the 'chat_history' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"chat_history\");\r",
									"});\r",
									"pm.test(\"Verify the 'done' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"done\", true);\r",
									"});\r",
									"pm.test(\"Verify the 'temp' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"temp\");\r",
									"});\r",
									"pm.test(\"Verify the 'answer_unknown' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"answer_unknown\", false);\r",
									"});\r",
									"pm.test(\"Verify the 'request_id' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"request_id\");\r",
									"});\r",
									"pm.test(\"Verify the 'request_time' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"request_time\");\r",
									"});\r",
									"pm.test(\"Verify the 'token_usage' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"token_usage\");\r",
									"});\r",
									"pm.test(\"Verify the 'response' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"response\");\r",
									"});\r",
									"pm.test(\"Verify the 'elapsed' field\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"elapsed\");\r",
									"});\r",
									"pm.test(\"Verify that 'chat_history' contains an array of messages\", function () {\r",
									"    pm.expect(pm.response.json().chat_history).to.be.an(\"array\");\r",
									"});\r",
									"//todo\r",
									"pm.test(\"Verify the content of the 'response' field\", function () {\r",
									"    pm.expect(pm.response.json().response).to.include(\"\");\r",
									"});\r",
									"pm.test(\"Verify the presence of 'Sources' in the 'response' field\", function () {\r",
									"    pm.expect(pm.response.json().response).to.include(\"Sources:\");\r",
									"});\r",
									"pm.test(\"Verify the 'token_usage' field has specific properties\", function () {\r",
									"    pm.expect(pm.response.json().token_usage).to.have.property(\"condense_llm_prompt\");\r",
									"    pm.expect(pm.response.json().token_usage).to.have.property(\"chat_llm_prompt\");\r",
									"    pm.expect(pm.response.json().token_usage).to.have.property(\"chat_llm_completion\");\r",
									"});\r",
									"pm.test(\"Verify that 'chat_history' contains at least one message\", function () {\r",
									"    pm.expect(pm.response.json().chat_history).to.have.length.above(0);\r",
									"});\r",
									"pm.test(\"Verify that 'chat_history' contains a message from the Human role\", function () {\r",
									"    const chatHistory = pm.response.json().chat_history;\r",
									"    const humanMessage = chatHistory.find((message) => message.role === \"Human\");\r",
									"    pm.expect(humanMessage).to.exist;\r",
									"});\r",
									"pm.test(\"Verify that 'chat_history' contains a message from the Assistant role\", function () {\r",
									"    const chatHistory = pm.response.json().chat_history;\r",
									"    const assistantMessage = chatHistory.find((message) => message.role === \"Assistant\");\r",
									"    pm.expect(assistantMessage).to.exist;\r",
									"});\r",
									"pm.test(\"Verify the 'request_time' field is a valid date format\", function () {\r",
									"    pm.expect(pm.response.json().request_time).to.match(/^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}.\\d{6}$/);\r",
									"});\r",
									"\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"chat_history\": [\r\n        {\r\n            \"role\": \"Human\",\r\n            \"content\": \"How do I change my laptop?\"\r\n        },\r\n        {\r\n            \"role\": \"Assistant\",\r\n            \"content\": \"You will need to submit a TSR request.\"\r\n        }\r\n    ],\r\n    \"query\": \"how?\",\r\n    \"language\": \"en\",\r\n    \"stream\": false,\r\n    \"return_docs\": false\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{url_np}}/2.0/bots/spoc",
							"host": [
								"{{url_np}}"
							],
							"path": [
								"2.0",
								"bots",
								"spoc"
							]
						}
					},
					"response": []
				},
				{
					"name": "/2.0/bots/public_mobile",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Response status code is 200\", function () {\r",
									"  pm.response.to.have.status(200);\r",
									"});\r",
									"pm.test(\"Response Schema Validation\", function () {\r",
									"    const jsonData = pm.response.json();    \r",
									"    const expectedSchema = {\r",
									"        \"query\": \"string\",\r",
									"        \"query_converted\": \"string\",\r",
									"        \"qie_status\": pm.expect(jsonData.qie_status).to.be.a(\"boolean\"),\r",
									"        \"chat_history\": [\r",
									"            {\r",
									"                \"role\": \"string\",\r",
									"                \"content\": \"string\"\r",
									"            }\r",
									"        ],\r",
									"        \"done\": pm.expect(jsonData.done).to.be.a(\"boolean\"),\r",
									"        \"temp\": pm.expect(jsonData.temp).to.be.a(\"number\"),\r",
									"        \"answer_unknown\": pm.expect(jsonData.answer_unknown).to.be.a(\"boolean\"),\r",
									"        \"request_id\": pm.expect(jsonData.request_id).to.be.a(\"number\"),\r",
									"        \"request_time\": \"string\",\r",
									"        \"token_usage\": {\r",
									"            \"condense_llm_prompt\": pm.expect(jsonData.token_usage.condense_llm_prompt).to.be.a(\"number\"),\r",
									"            \"chat_llm_prompt\": pm.expect(jsonData.token_usage.chat_llm_prompt).to.be.a(\"number\"),\r",
									"            \"chat_llm_completion\": pm.expect(jsonData.token_usage.chat_llm_completion).to.be.a(\"number\")\r",
									"        },\r",
									"        \"response\": \"string\",\r",
									"        \"elapsed\": pm.expect(jsonData.elapsed).to.be.a(\"number\")\r",
									"    };\r",
									"    // Function to validate the schema recursively\r",
									"    function validateSchema(obj, schema) {\r",
									"        for (const key in schema) {\r",
									"            if (typeof obj[key] !== \"undefined\") {\r",
									"                if (typeof schema[key] === \"object\") {\r",
									"                    validateSchema(obj[key], schema[key]);\r",
									"                }\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"\r",
									"    // Validate the response against the expected schema\r",
									"    validateSchema(jsonData, expectedSchema);\r",
									"});\r",
									"pm.test(\"Query should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.query).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"Query Converted should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.query_converted).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"QIE Status should be a boolean\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.qie_status).to.equal(\"boolean\");\r",
									"});\r",
									"pm.test(\"Chat History should be an array\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(Array.isArray(responseBody.chat_history)).to.be.true;\r",
									"});\r",
									"pm.test(\"Done should be a boolean\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.done).to.equal(\"boolean\");\r",
									"});\r",
									"pm.test(\"Temp should be a number\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.temp).to.equal(\"number\");\r",
									"});\r",
									"pm.test(\"Answer Unknown should be a boolean\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.answer_unknown).to.equal(\"boolean\");\r",
									"});\r",
									"pm.test(\"Request ID should be a number\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.request_id).to.equal(\"number\");\r",
									"});\r",
									"pm.test(\"Request Time should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.request_time).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"Token Usage should be an object\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.token_usage).to.equal(\"object\");\r",
									"});\r",
									"pm.test(\"Response should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.response).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"Elapsed should be a number\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.elapsed).to.equal(\"number\");\r",
									"});\r",
									"pm.test(\"Chat History should have at least one item\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.chat_history.length).to.be.above(0);\r",
									"});\r",
									"pm.test(\"Token Usage should contain required fields\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.token_usage).to.have.property(\"condense_llm_prompt\");\r",
									"    pm.expect(responseBody.token_usage).to.have.property(\"chat_llm_prompt\");\r",
									"    pm.expect(responseBody.token_usage).to.have.property(\"chat_llm_completion\");\r",
									"});\r",
									"pm.test(\"Chat History items should have 'role' and 'content'\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    responseBody.chat_history.forEach(function (item) {\r",
									"        pm.expect(item).to.have.property(\"role\");\r",
									"        pm.expect(item).to.have.property(\"content\");\r",
									"    });\r",
									"});\r",
									"//todo\r",
									"pm.test(\"Query Converted should contain 'PSO'\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.query_converted).to.include(\"\");\r",
									"});\r",
									"//todo\r",
									"pm.test(\"Response should mention 'TELUS'\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.response).to.include(\"Thank you\");\r",
									"});\r",
									"pm.test(\"Elapsed time should be greater than 2 seconds\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.elapsed).to.be.above(1);\r",
									"});\r",
									"pm.test(\"QIE Status should be true\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.qie_status).to.be.true;\r",
									"});\r",
									"pm.test(\"Done should be true\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.done).to.be.true;\r",
									"});\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"chat_history\": [\r\n        {\r\n            \"role\": \"Human\",\r\n            \"content\": \"How do I change my laptop?\"\r\n        },\r\n        {\r\n            \"role\": \"Assistant\",\r\n            \"content\": \"You will need to submit a TSR request.\"\r\n        }\r\n    ],\r\n    \"query\": \"how?\",\r\n    \"language\": \"en\",\r\n    \"stream\": false,\r\n    \"return_docs\": false\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{url_np}}/2.0/bots/public_mobile",
							"host": [
								"{{url_np}}"
							],
							"path": [
								"2.0",
								"bots",
								"public_mobile"
							]
						}
					},
					"response": []
				},
				{
					"name": "/2.0/bots/pnc",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"pm.test(\"Response Schema Validation\", function () {\r",
									"    const jsonData = pm.response.json();\r",
									"\r",
									"    // Define the expected schema\r",
									"    const expectedSchema = {\r",
									"        \"query\": \"string\",\r",
									"        \"query_converted\": \"string\",\r",
									"        \"qie_status\": pm.expect(jsonData.qie_status).to.be.a(\"boolean\"),\r",
									"        \"chat_history\": [\r",
									"            {\r",
									"                \"role\": \"string\",\r",
									"                \"content\": \"string\"\r",
									"            }\r",
									"        ],\r",
									"        \"done\": pm.expect(jsonData.done).to.be.a(\"boolean\"),\r",
									"        \"temp\": pm.expect(jsonData.temp).to.be.a(\"number\"),\r",
									"        \"answer_unknown\": pm.expect(jsonData.answer_unknown).to.be.a(\"boolean\"),\r",
									"        \"request_id\": pm.expect(jsonData.request_id).to.be.a(\"number\"),\r",
									"        \"request_time\": \"string\",\r",
									"        \"token_usage\": {\r",
									"            \"condense_llm_prompt\": pm.expect(jsonData.token_usage.condense_llm_prompt).to.be.a(\"number\"),\r",
									"            \"chat_llm_prompt\": pm.expect(jsonData.token_usage.chat_llm_prompt).to.be.a(\"number\"),\r",
									"            \"chat_llm_completion\": pm.expect(jsonData.token_usage.chat_llm_completion).to.be.a(\"number\")\r",
									"        },\r",
									"        \"response\": \"string\",\r",
									"        \"elapsed\": pm.expect(jsonData.elapsed).to.be.a(\"number\")\r",
									"    };\r",
									"\r",
									"    // Function to validate the schema recursively\r",
									"    function validateSchema(obj, schema) {\r",
									"        for (const key in schema) {\r",
									"            if (typeof obj[key] !== \"undefined\") {\r",
									"                if (typeof schema[key] === \"object\") {\r",
									"                    validateSchema(obj[key], schema[key]);\r",
									"                }\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"\r",
									"    // Validate the response against the expected schema\r",
									"    validateSchema(jsonData, expectedSchema);\r",
									"});\r",
									"pm.test(\"Query is a non-empty string\", function () {\r",
									"    pm.expect(pm.response.json().query).to.be.a(\"string\").and.not.empty;\r",
									"});\r",
									"pm.test(\"Query Converted is a non-empty string\", function () {\r",
									"    pm.expect(pm.response.json().query_converted).to.be.a(\"string\").and.not.empty;\r",
									"});\r",
									"pm.test(\"qie_status is a boolean\", function () {\r",
									"    pm.expect(pm.response.json().qie_status).to.be.a(\"boolean\");\r",
									"});\r",
									"pm.test(\"chat_history is an array with messages\", function () {\r",
									"    const chatHistory = pm.response.json().chat_history;\r",
									"    pm.expect(chatHistory).to.be.an(\"array\").and.not.empty;\r",
									"});\r",
									"pm.test(\"Each chat message has role and content\", function () {\r",
									"    const chatHistory = pm.response.json().chat_history;\r",
									"    chatHistory.forEach(function (message) {\r",
									"        pm.expect(message).to.have.property(\"role\").and.be.a(\"string\");\r",
									"        pm.expect(message).to.have.property(\"content\").and.be.a(\"string\");\r",
									"    });\r",
									"});\r",
									"pm.test(\"done is a boolean\", function () {\r",
									"    pm.expect(pm.response.json().done).to.be.a(\"boolean\");\r",
									"});\r",
									"pm.test(\"temp is a number\", function () {\r",
									"    pm.expect(pm.response.json().temp).to.be.a(\"number\");\r",
									"});\r",
									"pm.test(\"Response is successful\", function () {\r",
									"    pm.response.to.be.ok;\r",
									"});\r",
									"pm.test(\"Response is in JSON format\", function () {\r",
									"    pm.response.to.be.json;\r",
									"});\r",
									"pm.test(\"Response has a 'done' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"done\", true);\r",
									"});\r",
									"pm.test(\"Response has a 'response' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"response\");\r",
									"});\r",
									"pm.test(\"Response has an 'answer_unknown' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"answer_unknown\", false);\r",
									"});\r",
									"pm.test(\"Response has an 'elapsed' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"elapsed\");\r",
									"});\r",
									"pm.test(\"Response has a 'qie_status' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"qie_status\", true);\r",
									"});\r",
									"pm.test(\"Response has a 'chat_history' array\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"chat_history\").that.is.an(\"array\");\r",
									"});\r",
									"pm.test(\"Response 'chat_history' array has at least one item\", function () {\r",
									"    pm.expect(pm.response.json().chat_history).to.have.length.above(0);\r",
									"});\r",
									"pm.test(\"Response has a 'query_converted' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"query_converted\");\r",
									"});\r",
									"pm.test(\"Response has a 'request_id' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"request_id\");\r",
									"});\r",
									"pm.test(\"Response has a 'request_time' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"request_time\");\r",
									"});\r",
									"pm.test(\"Response has a 'token_usage' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"token_usage\");\r",
									"});\r",
									"pm.test(\"Response 'chat_history' array contains 'content' property\", function () {\r",
									"    pm.expect(pm.response.json().chat_history[0]).to.have.property(\"content\");\r",
									"});\r",
									"pm.test(\"Response 'response' property has expected value\", function () {\r",
									"    pm.expect(pm.response.json().response).to.eql(\"Sorry, the content required to answer your query does not seem to be included in the documentation at this time. We will pass this on to the relevant team for further investigation. Thank you!\");\r",
									"});\r",
									"pm.test(\"Response has a 'temp' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"temp\");\r",
									"});\r",
									"pm.test(\"Response has a 'query' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"query\");\r",
									"});\r",
									"pm.test(\"Response has a 'request_id' property\", function () {\r",
									"    pm.expect(pm.response.json()).to.have.property(\"request_id\");\r",
									"});\r",
									"pm.test(\"Response 'chat_history' array contains 'role' property with expected value\", function () {\r",
									"    pm.expect(pm.response.json().chat_history[0].role).to.eql(\"Human\");\r",
									"});\r",
									"\r",
									"\r",
									"\r",
									"\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"chat_history\": [\r\n        {\r\n            \"role\": \"Human\",\r\n            \"content\": \"How do I change my laptop?\"\r\n        },\r\n        {\r\n            \"role\": \"Assistant\",\r\n            \"content\": \"You will need to submit a TSR request.\"\r\n        }\r\n    ],\r\n    \"query\": \"how?\",\r\n    \"language\": \"en\",\r\n    \"stream\": false,\r\n    \"return_docs\": false\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{url_np}}/2.0/bots/pnc",
							"host": [
								"{{url_np}}"
							],
							"path": [
								"2.0",
								"bots",
								"pnc"
							]
						}
					},
					"response": []
				},
				{
					"name": "/2.0/bots/pso",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"pm.test(\"Response Schema Validation\", function () {\r",
									"    const jsonData = pm.response.json();    \r",
									"    const expectedSchema = {\r",
									"        \"query\": \"string\",\r",
									"        \"query_converted\": \"string\",\r",
									"        \"qie_status\": pm.expect(jsonData.qie_status).to.be.a(\"boolean\"),\r",
									"        \"chat_history\": [\r",
									"            {\r",
									"                \"role\": \"string\",\r",
									"                \"content\": \"string\"\r",
									"            }\r",
									"        ],\r",
									"        \"done\": pm.expect(jsonData.done).to.be.a(\"boolean\"),\r",
									"        \"temp\": pm.expect(jsonData.temp).to.be.a(\"number\"),\r",
									"        \"answer_unknown\": pm.expect(jsonData.answer_unknown).to.be.a(\"boolean\"),\r",
									"        \"request_id\": pm.expect(jsonData.request_id).to.be.a(\"number\"),\r",
									"        \"request_time\": \"string\",\r",
									"        \"token_usage\": {\r",
									"            \"condense_llm_prompt\": pm.expect(jsonData.token_usage.condense_llm_prompt).to.be.a(\"number\"),\r",
									"            \"chat_llm_prompt\": pm.expect(jsonData.token_usage.chat_llm_prompt).to.be.a(\"number\"),\r",
									"            \"chat_llm_completion\": pm.expect(jsonData.token_usage.chat_llm_completion).to.be.a(\"number\")\r",
									"        },\r",
									"        \"response\": \"string\",\r",
									"        \"elapsed\": pm.expect(jsonData.elapsed).to.be.a(\"number\")\r",
									"    };\r",
									"    // Function to validate the schema recursively\r",
									"    function validateSchema(obj, schema) {\r",
									"        for (const key in schema) {\r",
									"            if (typeof obj[key] !== \"undefined\") {\r",
									"                if (typeof schema[key] === \"object\") {\r",
									"                    validateSchema(obj[key], schema[key]);\r",
									"                }\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"\r",
									"    // Validate the response against the expected schema\r",
									"    validateSchema(jsonData, expectedSchema);\r",
									"});\r",
									"pm.test(\"Query should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.query).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"Query Converted should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.query_converted).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"QIE Status should be a boolean\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.qie_status).to.equal(\"boolean\");\r",
									"});\r",
									"pm.test(\"Chat History should be an array\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(Array.isArray(responseBody.chat_history)).to.be.true;\r",
									"});\r",
									"pm.test(\"Done should be a boolean\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.done).to.equal(\"boolean\");\r",
									"});\r",
									"pm.test(\"Temp should be a number\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.temp).to.equal(\"number\");\r",
									"});\r",
									"pm.test(\"Answer Unknown should be a boolean\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.answer_unknown).to.equal(\"boolean\");\r",
									"});\r",
									"pm.test(\"Request ID should be a number\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.request_id).to.equal(\"number\");\r",
									"});\r",
									"pm.test(\"Request Time should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.request_time).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"Token Usage should be an object\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.token_usage).to.equal(\"object\");\r",
									"});\r",
									"pm.test(\"Response should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.response).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"Elapsed should be a number\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.elapsed).to.equal(\"number\");\r",
									"});\r",
									"pm.test(\"Chat History should have at least one item\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.chat_history.length).to.be.above(0);\r",
									"});\r",
									"pm.test(\"Token Usage should contain required fields\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.token_usage).to.have.property(\"condense_llm_prompt\");\r",
									"    pm.expect(responseBody.token_usage).to.have.property(\"chat_llm_prompt\");\r",
									"    pm.expect(responseBody.token_usage).to.have.property(\"chat_llm_completion\");\r",
									"});\r",
									"pm.test(\"Chat History items should have 'role' and 'content'\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    responseBody.chat_history.forEach(function (item) {\r",
									"        pm.expect(item).to.have.property(\"role\");\r",
									"        pm.expect(item).to.have.property(\"content\");\r",
									"    });\r",
									"});\r",
									"pm.test(\"Query Converted should contain 'PSO'\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.query_converted).to.include(\"PSO\");\r",
									"});\r",
									"pm.test(\"Response should mention 'TELUS'\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.response).to.include(\"TELUS\");\r",
									"});\r",
									"pm.test(\"Elapsed time should be greater than 2 seconds\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.elapsed).to.be.above(2);\r",
									"});\r",
									"pm.test(\"QIE Status should be true\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.qie_status).to.be.true;\r",
									"});\r",
									"pm.test(\"Done should be true\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.done).to.be.true;\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"chat_history\": [\r\n        {\r\n            \"role\": \"Human\",\r\n            \"content\": \"What is PSO?\"\r\n        },\r\n        {\r\n            \"role\": \"Assistant\",\r\n            \"content\": \"Premier Sales Organization.\"\r\n        }\r\n    ],\r\n    \"query\": \"how?\",\r\n    \"language\": \"en\",\r\n    \"stream\": false,\r\n    \"return_docs\": false\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{url_np}}/2.0/bots/pso",
							"host": [
								"{{url_np}}"
							],
							"path": [
								"2.0",
								"bots",
								"pso"
							]
						}
					},
					"response": []
				},
				{
					"name": "/2.0/bots/tcom_support",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"pm.test(\"Response Schema Validation\", function () {\r",
									"    const jsonData = pm.response.json();    \r",
									"    const expectedSchema = {\r",
									"        \"query\": \"string\",\r",
									"        \"query_converted\": \"string\",\r",
									"        \"qie_status\": pm.expect(jsonData.qie_status).to.be.a(\"boolean\"),\r",
									"        \"chat_history\": [\r",
									"            {\r",
									"                \"role\": \"string\",\r",
									"                \"content\": \"string\"\r",
									"            }\r",
									"        ],\r",
									"        \"done\": pm.expect(jsonData.done).to.be.a(\"boolean\"),\r",
									"        \"temp\": pm.expect(jsonData.temp).to.be.a(\"number\"),\r",
									"        \"answer_unknown\": pm.expect(jsonData.answer_unknown).to.be.a(\"boolean\"),\r",
									"        \"request_id\": pm.expect(jsonData.request_id).to.be.a(\"number\"),\r",
									"        \"request_time\": \"string\",\r",
									"        \"token_usage\": {\r",
									"            \"condense_llm_prompt\": pm.expect(jsonData.token_usage.condense_llm_prompt).to.be.a(\"number\"),\r",
									"            \"chat_llm_prompt\": pm.expect(jsonData.token_usage.chat_llm_prompt).to.be.a(\"number\"),\r",
									"            \"chat_llm_completion\": pm.expect(jsonData.token_usage.chat_llm_completion).to.be.a(\"number\")\r",
									"        },\r",
									"        \"response\": \"string\",\r",
									"        \"elapsed\": pm.expect(jsonData.elapsed).to.be.a(\"number\")\r",
									"    };\r",
									"    // Function to validate the schema recursively\r",
									"    function validateSchema(obj, schema) {\r",
									"        for (const key in schema) {\r",
									"            if (typeof obj[key] !== \"undefined\") {\r",
									"                if (typeof schema[key] === \"object\") {\r",
									"                    validateSchema(obj[key], schema[key]);\r",
									"                }\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"\r",
									"    // Validate the response against the expected schema\r",
									"    validateSchema(jsonData, expectedSchema);\r",
									"});\r",
									"pm.test(\"Query should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.query).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"Query Converted should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.query_converted).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"QIE Status should be a boolean\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.qie_status).to.equal(\"boolean\");\r",
									"});\r",
									"pm.test(\"Chat History should be an array\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(Array.isArray(responseBody.chat_history)).to.be.true;\r",
									"});\r",
									"pm.test(\"Done should be a boolean\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.done).to.equal(\"boolean\");\r",
									"});\r",
									"pm.test(\"Temp should be a number\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.temp).to.equal(\"number\");\r",
									"});\r",
									"pm.test(\"Answer Unknown should be a boolean\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.answer_unknown).to.equal(\"boolean\");\r",
									"});\r",
									"pm.test(\"Request ID should be a number\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.request_id).to.equal(\"number\");\r",
									"});\r",
									"pm.test(\"Request Time should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.request_time).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"Token Usage should be an object\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.token_usage).to.equal(\"object\");\r",
									"});\r",
									"pm.test(\"Response should be a string\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.response).to.equal(\"string\");\r",
									"});\r",
									"pm.test(\"Elapsed should be a number\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(typeof responseBody.elapsed).to.equal(\"number\");\r",
									"});\r",
									"pm.test(\"Chat History should have at least one item\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.chat_history.length).to.be.above(0);\r",
									"});\r",
									"pm.test(\"Token Usage should contain required fields\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.token_usage).to.have.property(\"condense_llm_prompt\");\r",
									"    pm.expect(responseBody.token_usage).to.have.property(\"chat_llm_prompt\");\r",
									"    pm.expect(responseBody.token_usage).to.have.property(\"chat_llm_completion\");\r",
									"});\r",
									"pm.test(\"Chat History items should have 'role' and 'content'\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    responseBody.chat_history.forEach(function (item) {\r",
									"        pm.expect(item).to.have.property(\"role\");\r",
									"        pm.expect(item).to.have.property(\"content\");\r",
									"    });\r",
									"});\r",
									"pm.test(\"Query Converted should contain ''\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.query_converted).to.include(\"\");\r",
									"});\r",
									"pm.test(\"Response should mention 'TELUS'\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.response).to.include(\"TELUS\");\r",
									"});\r",
									"pm.test(\"Elapsed time should be greater than 2 seconds\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.elapsed).to.be.above(2);\r",
									"});\r",
									"pm.test(\"QIE Status should be true\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.qie_status).to.be.true;\r",
									"});\r",
									"pm.test(\"Done should be true\", function () {\r",
									"    const responseBody = pm.response.json();\r",
									"    pm.expect(responseBody.done).to.be.true;\r",
									"});\r",
									"\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"chat_history\": [\r\n        {\r\n            \"role\": \"Human\",\r\n            \"content\": \"Can I cancel Stream+ at any time? \"\r\n        },\r\n        {\r\n            \"role\": \"Assistant\",\r\n            \"content\": \"Yes, you can cancel your Stream+ add-on at any time through My TELUS.\"\r\n        }\r\n    ],\r\n    \"query\": \"how?\",\r\n    \"language\": \"en\",\r\n    \"stream\": false,\r\n    \"return_docs\": false\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{url_np}}/2.0/bots/tcom_support",
							"host": [
								"{{url_np}}"
							],
							"path": [
								"2.0",
								"bots",
								"tcom_support"
							]
						}
					},
					"response": []
				},
				{
					"name": "/2.0/summarize",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {\r",
									"    pm.response.to.have.status(200);\r",
									"});\r",
									"pm.test(\"Response Schema Validation\", function () {\r",
									"    const jsonData = pm.response.json();\r",
									"    \r",
									"    // Define the expected schema\r",
									"    const expectedSchema = {\r",
									"        \"query\": [],\r",
									"        \"summary\": \"string\",\r",
									"        \"summary_type\": \"string\",\r",
									"        \"elapsed:\": pm.expect(jsonData[\"elapsed:\"]).to.be.a(\"number\"),\r",
									"        \"token count\": {\r",
									"            \"successful_requests\": pm.expect(jsonData[\"token count\"].successful_requests).to.be.a(\"number\"),\r",
									"            \"total_cost\": pm.expect(jsonData[\"token count\"].total_cost).to.be.a(\"number\"),\r",
									"            \"total_tokens\": pm.expect(jsonData[\"token count\"].total_tokens).to.be.a(\"number\"),\r",
									"            \"prompt_tokens\": pm.expect(jsonData[\"token count\"].prompt_tokens).to.be.a(\"number\"),\r",
									"            \"completion_tokens\": pm.expect(jsonData[\"token count\"].completion_tokens).to.be.a(\"number\")\r",
									"        }\r",
									"    };\r",
									"\r",
									"    // Function to validate the schema recursively\r",
									"    function validateSchema(obj, schema) {\r",
									"        for (const key in schema) {\r",
									"            if (typeof obj[key] !== \"undefined\") {\r",
									"                if (typeof schema[key] === \"object\") {\r",
									"                    validateSchema(obj[key], schema[key]);\r",
									"                }\r",
									"            }\r",
									"        }\r",
									"    }\r",
									"\r",
									"    // Validate the response against the expected schema\r",
									"    validateSchema(jsonData, expectedSchema);\r",
									"});\r",
									"const jsonData = pm.response.json();\r",
									"pm.test(\"Query is an empty array\", function () {\r",
									"    pm.expect(jsonData.query).to.eql([]);\r",
									"});\r",
									"pm.test(\"Summary is a string\", function () {\r",
									"    pm.expect(jsonData.summary).to.be.a(\"string\");\r",
									"});\r",
									"pm.test(\"Summary Type is a string\", function () {\r",
									"    pm.expect(jsonData.summary_type).to.be.a(\"string\");\r",
									"});\r",
									"pm.test(\"Elapsed time is a number\", function () {\r",
									"    pm.expect(jsonData[\"elapsed:\"]).to.be.a(\"number\");\r",
									"});\r",
									"pm.test(\"Token Count is an object\", function () {\r",
									"    pm.expect(jsonData[\"token count\"]).to.be.an(\"object\");\r",
									"});\r",
									"pm.test(\"Successful Requests is a number\", function () {\r",
									"    pm.expect(jsonData[\"token count\"].successful_requests).to.be.a(\"number\");\r",
									"});\r",
									"pm.test(\"Total Cost is a number\", function () {\r",
									"    pm.expect(jsonData[\"token count\"].total_cost).to.be.a(\"number\");\r",
									"});\r",
									"pm.test(\"Total Tokens is a number\", function () {\r",
									"    pm.expect(jsonData[\"token count\"].total_tokens).to.be.a(\"number\");\r",
									"});\r",
									"pm.test(\"Prompt Tokens is a number\", function () {\r",
									"    pm.expect(jsonData[\"token count\"].prompt_tokens).to.be.a(\"number\");\r",
									"});\r",
									"pm.test(\"Completion Tokens is a number\", function () {\r",
									"    pm.expect(jsonData[\"token count\"].completion_tokens).to.be.a(\"number\");\r",
									"});\r",
									"pm.test(\"Elapsed time is greater than 0\", function () {\r",
									"    pm.expect(jsonData[\"elapsed:\"]).to.be.above(0);\r",
									"});\r",
									"pm.test(\"Successful Requests is greater than or equal to 1\", function () {\r",
									"    pm.expect(jsonData[\"token count\"].successful_requests).to.be.at.least(1);\r",
									"});\r",
									"pm.test(\"Total Cost is greater than or equal to 0\", function () {\r",
									"    pm.expect(jsonData[\"token count\"].total_cost).to.be.at.least(0);\r",
									"});\r",
									"pm.test(\"Total Tokens is greater than or equal to 0\", function () {\r",
									"    pm.expect(jsonData[\"token count\"].total_tokens).to.be.at.least(0);\r",
									"});\r",
									"pm.test(\"Prompt Tokens is greater than or equal to 0\", function () {\r",
									"    pm.expect(jsonData[\"token count\"].prompt_tokens).to.be.at.least(0);\r",
									"});\r",
									"pm.test(\"Completion Tokens is greater than or equal to 0\", function () {\r",
									"    pm.expect(jsonData[\"token count\"].completion_tokens).to.be.at.least(0);\r",
									"});\r",
									"pm.test(\"Summary Type is 'Stuff Summary'\", function () {\r",
									"    pm.expect(jsonData.summary_type).to.equal(\"Stuff Summary\");\r",
									"});\r",
									"pm.test(\"Token Count contains expected properties\", function () {\r",
									"    pm.expect(jsonData[\"token count\"]).to.have.all.keys(\r",
									"        \"successful_requests\",\r",
									"        \"total_cost\",\r",
									"        \"total_tokens\",\r",
									"        \"prompt_tokens\",\r",
									"        \"completion_tokens\"\r",
									"    );\r",
									"});\r",
									"pm.test(\"Query is an empty array\", function () {\r",
									"    pm.expect(jsonData.query).to.be.an(\"array\").that.is.empty;\r",
									"});\r",
									"pm.test(\"Summary contains specific text\", function () {\r",
									"    pm.expect(jsonData.summary).to.include(\"The summary is missing as there is no provided text to summarize.\");\r",
									"});\r",
									""
								],
								"type": "text/javascript"
							}
						}
					],
					"request": {
						"auth": {
							"type": "bearer",
							"bearer": [
								{
									"key": "token",
									"value": "{{access_token}}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"query\": \"string\",\r\n    \"temperature\": 0,\r\n    \"collection_name\": \"string\",\r\n    \"content_filter\": \"string\",\r\n    \"prompt_type\": \"default\"\r\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "{{url_np}}/2.0/summarize",
							"host": [
								"{{url_np}}"
							],
							"path": [
								"2.0",
								"summarize"
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					"// Define the OAuth 2.0 token request parameters",
					"const tokenUrl = pm.environment.get('access_token_url');",
					"const clientId = pm.environment.get('client_id');",
					"const clientSecret = pm.environment.get('client_secret');",
					"const scope = pm.environment.get('scope');",
					"",
					"pm.sendRequest({",
					"    url: tokenUrl,",
					"    method: \"POST\",",
					"    header: [",
					"        'Content-Type:application/x-www-form-urlencoded'",
					"    ],",
					"    body: {",
					"        mode: \"urlencoded\",",
					"        urlencoded: [",
					"            {key: \"client_id\", value: clientId},",
					"            {key: \"client_secret\", value: clientSecret},",
					"            {key: \"scope\", value: scope},",
					"            {key: \"grant_type\", value: \"client_credentials\"}",
					"        ]",
					"    },",
					"},",
					"(error, response) => {    ",
					"    pm.environment.set(\"access_token\", response.json().access_token);    ",
					"});"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}